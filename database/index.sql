-- This script was generated by the ERD tool in pgAdmin 4.
-- Please log an issue at https://redmine.postgresql.org/projects/pgadmin4/issues/new if you find any bugs, including reproduction steps.
BEGIN;

-- FUNCIONES

CREATE OR REPLACE FUNCTION public.get_tutorias_impartidas(
    tutor_id character varying)
    RETURNS TABLE(asignaturas_impartidas character varying) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
BEGIN
    RETURN QUERY 
    SELECT 
        CAST(string_agg(a.nombreasignatura || ' - $' || tu.precio::text || ' CLP', ', ') AS character varying) AS asignaturas_impartidas
    FROM imparten tu
    JOIN asignaturas a ON tu.codigo_asignatura = a.codigo AND tu.id_universidad = a.id_universidad
    WHERE tu.id_tutor = tutor_id;
END; 
$BODY$;

ALTER FUNCTION public.get_tutorias_impartidas(character varying)
    OWNER TO postgres;
-- FUNCTION: public.generar_id_grupos()

-- DROP FUNCTION IF EXISTS public.generar_id_grupos();

CREATE OR REPLACE FUNCTION public.generar_id_grupos(
	)
    RETURNS character varying
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
declare
    nuevo_id VARCHAR;
begin
    nuevo_id := substr(md5(random()::text), 1, 8);
	while exists (select 1 from grupos where id = nuevo_id) loop
        nuevo_id := substr(md5(random()::text), 1, 8);
    end loop;
    return nuevo_id;
end;
$BODY$;

ALTER FUNCTION public.generar_id_grupos()
    OWNER TO postgres;

-- FUNCTION: public.generar_id_usuarios()

-- DROP FUNCTION IF EXISTS public.generar_id_usuarios();

CREATE OR REPLACE FUNCTION public.generar_id_usuarios(
	)
    RETURNS character varying
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
declare
    nuevo_id VARCHAR;
begin
    nuevo_id := substr(md5(random()::text), 1, 8);
	while exists (select 1 from usuarios where id = nuevo_id) loop
        nuevo_id := substr(md5(random()::text), 1, 8);
    end loop;
    return nuevo_id;
end;
$BODY$;

ALTER FUNCTION public.generar_id_usuarios()
    OWNER TO postgres;

-- FUNCTION: public.get_asignaturas_tutor(character varying)

-- DROP FUNCTION IF EXISTS public.get_asignaturas_tutor(character varying);

CREATE OR REPLACE FUNCTION public.get_asignaturas_tutor(
	tutor_id character varying)
    RETURNS TABLE(codigo character varying, nombreasignatura character varying) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
BEGIN
    RETURN QUERY 
    SELECT a.codigo, a.nombreasignatura
    FROM tutorias tu 
    INNER JOIN asignaturas a ON tu.codigoasignatura = a.codigo
    WHERE tu.id_tutor = tutor_id;
END; 
$BODY$;

ALTER FUNCTION public.get_asignaturas_tutor(character varying)
    OWNER TO postgres;
-- FUNCTION: public.get_tutoria_precio_mas_bajo(character varying)

-- DROP FUNCTION IF EXISTS public.get_tutoria_precio_mas_bajo(character varying);

CREATE OR REPLACE FUNCTION public.get_tutoria_precio_mas_bajo(
	tutor_id character varying)
    RETURNS TABLE(id integer, hora character varying, fecha character varying, codigoasignatura character varying, descripcion character varying, precioporhora double precision, modalidad character varying, id_estudiante character varying, id_tutor character varying, cantidadmaximaestudiante integer, horafinal character varying) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
BEGIN
    RETURN QUERY 
    SELECT tu.* 
    FROM tutorias tu 
    WHERE tu.id_tutor = tutor_id
    ORDER BY tu.precioporhora ASC
    LIMIT 1;
END; 
$BODY$;

ALTER FUNCTION public.get_tutoria_precio_mas_bajo(character varying)
    OWNER TO postgres;

-- FUNCTION: public.obtener_promedio_calificacion(character varying)

-- DROP FUNCTION IF EXISTS public.obtener_promedio_calificacion(character varying);
-- verison antigua
--CREATE OR REPLACE FUNCTION public.obtener_promedio_calificacion(
--	p_id_tutor character varying)
--    RETURNS double precision
--    LANGUAGE 'plpgsql'
--    COST 100
--    VOLATILE PARALLEL UNSAFE
--AS $BODY$
--DECLARE
--    promedio_calificacion FLOAT;
--BEGIN
--    SELECT AVG(calificacion) INTO promedio_calificacion
--    FROM comentarios
 --   WHERE id_tutor = p_id_tutor;

 --   RETURN promedio_calificacion;
--END; 
--$BODY$;
--ALTER FUNCTION public.obtener_promedio_calificacion(character varying)
  --  OWNER TO postgres;
-- version nueva


-- FUNCTION: public.obtener_promedio_calificacion(character varying)

-- DROP FUNCTION IF EXISTS public.obtener_promedio_calificacion(character varying);

-- FUNCTION: public.obtener_promedio_calificacion(character varying)

-- DROP FUNCTION IF EXISTS public.obtener_promedio_calificacion(character varying);

-- FUNCTION: public.obtener_promedio_calificacion(character varying, boolean, double precision)

-- DROP FUNCTION IF EXISTS public.obtener_promedio_calificacion(character varying, boolean, double precision);

CREATE OR REPLACE FUNCTION public.obtener_promedio_calificacion(
	p_id_tutor character varying,
	aproximar boolean,
	intervalo double precision)
    RETURNS double precision
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    promedio_calificacion FLOAT;
BEGIN
    SELECT AVG(calificacion) INTO promedio_calificacion
    FROM comentarios
    WHERE id_tutor = p_id_tutor;

    IF aproximar THEN
        promedio_calificacion := ROUND(promedio_calificacion / intervalo) * intervalo;
    END IF;

    RETURN promedio_calificacion;
END; 
$BODY$;

ALTER FUNCTION public.obtener_promedio_calificacion(character varying, boolean, double precision)
    OWNER TO postgres;


-- FUNCTION: public.obtener_promedio_calificacion(character varying)

-- DROP FUNCTION IF EXISTS public.obtener_promedio_calificacion(character varying);

CREATE OR REPLACE FUNCTION public.obtener_promedio_calificacion(
	p_id_tutor character varying)
    RETURNS double precision
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    RETURN obtener_promedio_calificacion(p_id_tutor, false, 0.5);
END; 
$BODY$;

ALTER FUNCTION public.obtener_promedio_calificacion(character varying)
    OWNER TO postgres;

-- SEQUENCE: public.horariosdisponibles_id_seq

-- DROP SEQUENCE IF EXISTS public.horariosdisponibles_id_seq;

CREATE SEQUENCE IF NOT EXISTS public.horariosdisponibles_id_seq
    INCREMENT 1
    START 1
    MINVALUE 1
    MAXVALUE 2147483647
    CACHE 1;
	
ALTER SEQUENCE public.horariosdisponibles_id_seq
    OWNER TO postgres;
	
	
	-- SEQUENCE: public.reportes_id_seq

-- DROP SEQUENCE IF EXISTS public.reportes_id_seq;

CREATE SEQUENCE IF NOT EXISTS public.reportes_id_seq
    INCREMENT 1
    START 1
    MINVALUE 1
    MAXVALUE 2147483647
    CACHE 1;

ALTER SEQUENCE public.reportes_id_seq
    OWNER TO postgres;
	
	
-- SEQUENCE: public.solicitudes_id_seq

-- DROP SEQUENCE IF EXISTS public.solicitudes_id_seq;

CREATE SEQUENCE IF NOT EXISTS public.solicitudes_id_seq
    INCREMENT 1
    START 1
    MINVALUE 1
    MAXVALUE 2147483647
    CACHE 1;
	
ALTER SEQUENCE public.solicitudes_id_seq
    OWNER TO postgres;
	
	
-- SEQUENCE: public.tutorias_id_seq

-- DROP SEQUENCE IF EXISTS public.tutorias_id_seq;

CREATE SEQUENCE IF NOT EXISTS public.tutorias_id_seq
    INCREMENT 1
    START 1
    MINVALUE 1
    MAXVALUE 2147483647
    CACHE 1;

ALTER SEQUENCE public.tutorias_id_seq
    OWNER TO postgres;
	

-- SEQUENCE: public.universidades_id_seq

-- DROP SEQUENCE IF EXISTS public.universidades_id_seq;

CREATE SEQUENCE IF NOT EXISTS public.universidades_id_seq
    INCREMENT 1
    START 1
    MINVALUE 1
    MAXVALUE 2147483647
    CACHE 1;
ALTER SEQUENCE public.universidades_id_seq
    OWNER TO postgres;



CREATE TABLE IF NOT EXISTS public.administradores
(
    id character varying(200) COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT administradores_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS public.asignaturas
(
    codigo character varying(200) COLLATE pg_catalog."default" NOT NULL,
    nombreasignatura character varying(200) COLLATE pg_catalog."default" NOT NULL,
    id_universidad integer NOT NULL,
    CONSTRAINT asignaturas_pkey PRIMARY KEY (codigo, id_universidad)
);

CREATE TABLE IF NOT EXISTS public.clasifica
(
    id_estudiante character varying(200) COLLATE pg_catalog."default" NOT NULL,
    id_tutoria integer NOT NULL,
    CONSTRAINT clasifica_pkey PRIMARY KEY (id_estudiante, id_tutoria)
);

CREATE TABLE IF NOT EXISTS public.comentarios
(
    id_estudiante character varying(200) COLLATE pg_catalog."default" NOT NULL,
    id_tutor character varying(200) COLLATE pg_catalog."default" NOT NULL,
    comentario character varying(200) COLLATE pg_catalog."default" NOT NULL,
    calificacion integer NOT NULL,
    CONSTRAINT comentarios_pkey PRIMARY KEY (id_estudiante, id_tutor)
);

CREATE TABLE IF NOT EXISTS public.estudiantes
(
    id character varying(200) COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT estudiantes_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS public.grupos
(
    id character varying(200) COLLATE pg_catalog."default" NOT NULL,
    id_tutor character varying(200) COLLATE pg_catalog."default" NOT NULL,
    nombregrupo character varying(200) COLLATE pg_catalog."default" NOT NULL,
    descripcion character varying(200) COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT grupos_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS public.horariosdisponibles
(
    id integer NOT NULL DEFAULT nextval('horariosdisponibles_id_seq'::regclass),
    hora character varying(200) COLLATE pg_catalog."default" NOT NULL,
    dia character varying(200) COLLATE pg_catalog."default" NOT NULL,
    id_usuario character varying(200) COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT horariosdisponibles_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS public.mensajes
(
    id character varying(200) COLLATE pg_catalog."default" NOT NULL,
    mensaje character varying(500) COLLATE pg_catalog."default" NOT NULL,
    id_receptor character varying(200) COLLATE pg_catalog."default" NOT NULL,
    id_emisor character varying(200) COLLATE pg_catalog."default" NOT NULL,
    id_grupo character varying(200) COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT mensajes_pkey PRIMARY KEY (id)
);

-- Table: public.reportes

-- DROP TABLE IF EXISTS public.reportes;

CREATE TABLE IF NOT EXISTS public.reportes
(
    id integer NOT NULL DEFAULT nextval('reportes_id_seq'::regclass),
    motivo character varying(100) COLLATE pg_catalog."default",
    detalles character varying(500) COLLATE pg_catalog."default",
    id_reportado character varying(200) COLLATE pg_catalog."default",
    id_usuario_reporto character varying(200) COLLATE pg_catalog."default",
    fecha_reporte timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT reportes_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS public.seune
(
    id_estudiante character varying(200) COLLATE pg_catalog."default" NOT NULL,
    id_grupo character varying(200) COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT seune_pkey PRIMARY KEY (id_estudiante, id_grupo)
);

CREATE TABLE IF NOT EXISTS public.solicitudes
(
    id integer NOT NULL DEFAULT nextval('solicitudes_id_seq'::regclass),
    hora timestamp without time zone NOT NULL DEFAULT now(),
    fecha date NOT NULL DEFAULT CURRENT_DATE,
    id_asignatura character varying(200) COLLATE pg_catalog."default" NOT NULL,
    descripcion character varying(200) COLLATE pg_catalog."default" NOT NULL,
    estado character varying(200) COLLATE pg_catalog."default" NOT NULL DEFAULT 'Pendiente'::character varying,
    modalidad character varying(200) COLLATE pg_catalog."default" NOT NULL,
    id_estudiante character varying(200) COLLATE pg_catalog."default" NOT NULL,
    id_tutor character varying(200) COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT solicitudes_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS public.tutores
(
    id character varying(200) COLLATE pg_catalog."default" NOT NULL,
    nombrediscord character varying(200) COLLATE pg_catalog."default",
    CONSTRAINT tutores_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS public.tutorias
(
    id integer NOT NULL DEFAULT nextval('tutorias_id_seq'::regclass),
    hora character varying(200) COLLATE pg_catalog."default" NOT NULL,
    fecha character varying(200) COLLATE pg_catalog."default" NOT NULL,
    codigoasignatura character varying(200) COLLATE pg_catalog."default" NOT NULL,
    descripcion character varying(200) COLLATE pg_catalog."default" NOT NULL,
    precioporhora double precision NOT NULL,
    modalidad character varying(200) COLLATE pg_catalog."default" NOT NULL,
    id_estudiante character varying(200) COLLATE pg_catalog."default" NOT NULL,
    id_tutor character varying(200) COLLATE pg_catalog."default" NOT NULL,
    cantidadmaximaestudiantes integer,
    horafinal character varying(200) COLLATE pg_catalog."default",
    CONSTRAINT tutorias_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS public.universidades
(
    id integer NOT NULL DEFAULT nextval('universidades_id_seq'::regclass),
    nombre character varying(200) COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT universidades_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS public.usuarios
(
    id character varying(200) COLLATE pg_catalog."default" NOT NULL,
    nombre character varying(200) COLLATE pg_catalog."default" NOT NULL,
    correo character varying(200) COLLATE pg_catalog."default" NOT NULL,
    id_universidad integer NOT NULL,
    contrasenia character varying(200) COLLATE pg_catalog."default" NOT NULL,
    fechanacimiento character varying(200) COLLATE pg_catalog."default" NOT NULL,
    genero character varying(200) COLLATE pg_catalog."default",
    telefono character varying(200) COLLATE pg_catalog."default",
    id_estudiante character varying(200) COLLATE pg_catalog."default",
    id_tutor character varying(200) COLLATE pg_catalog."default",
    descripcion character varying(500) COLLATE pg_catalog."default",
    id_administrador character varying(200) COLLATE pg_catalog."default",
    CONSTRAINT usuarios_pkey PRIMARY KEY (id)
);

ALTER TABLE IF EXISTS public.administradores
    ADD CONSTRAINT administradores_id_fkey FOREIGN KEY (id)
    REFERENCES public.usuarios (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS administradores_pkey
    ON public.administradores(id);


ALTER TABLE IF EXISTS public.asignaturas
    ADD CONSTRAINT asignaturas_id_universidad_fkey FOREIGN KEY (id_universidad)
    REFERENCES public.universidades (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.clasifica
    ADD CONSTRAINT clasifica_id_estudiante_fkey FOREIGN KEY (id_estudiante)
    REFERENCES public.estudiantes (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.clasifica
    ADD CONSTRAINT clasifica_id_tutoria_fkey FOREIGN KEY (id_tutoria)
    REFERENCES public.tutorias (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.comentarios
    ADD CONSTRAINT comentarios_id_estudiante_fkey FOREIGN KEY (id_estudiante)
    REFERENCES public.estudiantes (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.comentarios
    ADD CONSTRAINT comentarios_id_tutor_fkey FOREIGN KEY (id_tutor)
    REFERENCES public.tutores (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.estudiantes
    ADD CONSTRAINT estudiantes_id_fkey FOREIGN KEY (id)
    REFERENCES public.usuarios (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS estudiantes_pkey
    ON public.estudiantes(id);


ALTER TABLE IF EXISTS public.horariosdisponibles
    ADD CONSTRAINT horariosdisponibles_id_usuario_fkey FOREIGN KEY (id_usuario)
    REFERENCES public.usuarios (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.mensajes
    ADD CONSTRAINT mensajes_id_emisor_fkey FOREIGN KEY (id_emisor)
    REFERENCES public.usuarios (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.mensajes
    ADD CONSTRAINT mensajes_id_grupo_fkey FOREIGN KEY (id_grupo)
    REFERENCES public.grupos (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.mensajes
    ADD CONSTRAINT mensajes_id_receptor_fkey FOREIGN KEY (id_receptor)
    REFERENCES public.usuarios (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.seune
    ADD CONSTRAINT seune_id_estudiante_fkey FOREIGN KEY (id_estudiante)
    REFERENCES public.estudiantes (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.seune
    ADD CONSTRAINT seune_id_grupo_fkey FOREIGN KEY (id_grupo)
    REFERENCES public.grupos (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.solicitudes
    ADD CONSTRAINT solicitudes_id_estudiante_fkey FOREIGN KEY (id_estudiante)
    REFERENCES public.estudiantes (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.solicitudes
    ADD CONSTRAINT solicitudes_id_tutor_fkey FOREIGN KEY (id_tutor)
    REFERENCES public.tutores (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.tutores
    ADD CONSTRAINT tutores_id_fkey FOREIGN KEY (id)
    REFERENCES public.usuarios (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS tutores_pkey
    ON public.tutores(id);


ALTER TABLE IF EXISTS public.tutorias
    ADD CONSTRAINT tutorias_id_estudiante_fkey FOREIGN KEY (id_estudiante)
    REFERENCES public.estudiantes (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.tutorias
    ADD CONSTRAINT tutorias_id_tutor_fkey FOREIGN KEY (id_tutor)
    REFERENCES public.tutores (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.usuarios
    ADD CONSTRAINT usuarios_id_administrador_fkey FOREIGN KEY (id_administrador)
    REFERENCES public.administradores (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.usuarios
    ADD CONSTRAINT usuarios_id_estudiante_fkey FOREIGN KEY (id_estudiante)
    REFERENCES public.estudiantes (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.usuarios
    ADD CONSTRAINT usuarios_id_tutor_fkey FOREIGN KEY (id_tutor)
    REFERENCES public.tutores (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.usuarios
    ADD CONSTRAINT usuarios_id_universidad_fkey FOREIGN KEY (id_universidad)
    REFERENCES public.universidades (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;

-- Creado manualmente

ALTER SEQUENCE public.horariosdisponibles_id_seq
    OWNED BY horariosdisponibles.id;
ALTER SEQUENCE public.reportes_id_seq
    OWNED BY reportes.id;

ALTER SEQUENCE public.solicitudes_id_seq
    OWNED BY solicitudes.id;

ALTER SEQUENCE public.tutorias_id_seq
    OWNED BY tutorias.id;

ALTER SEQUENCE public.universidades_id_seq
    OWNED BY universidades.id;


-- Crear la tabla intermedia 'imparten'
CREATE TABLE imparten (
    id_tutor VARCHAR(200),
    codigo_asignatura VARCHAR(200),
    id_universidad INTEGER,
    PRIMARY KEY (id_tutor, codigo_asignatura, id_universidad),
    FOREIGN KEY (id_tutor) REFERENCES tutores(id),
    FOREIGN KEY (codigo_asignatura, id_universidad) REFERENCES asignaturas(codigo, id_universidad)
);
alter table imparten add column nombre_asignatura varchar(200);
alter table tutorias add column clave varchar(200);

END;

